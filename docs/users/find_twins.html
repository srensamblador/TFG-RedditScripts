<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>src.users.find_twins API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>src.users.find_twins</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import argparse
from elasticsearch import Elasticsearch, helpers
from psaw import PushshiftAPI
from datetime import date
from datetime import datetime as dt
from datetime import timedelta
import progressbar as pb
import pprint as pp
import pickle

import requests


MAX_USERS = 1000

def main(args):
    global es, api
    es = Elasticsearch(args.elasticsearch)
    
    # Extraer usuarios del primer índice
    print(&#34;Recuperando usuarios de /r/lonely...&#34;)
    users = get_users(args.source_users)

    # Buscar usuarios &#34;gemelos&#34;
    print(&#34;Obteniendo posibles gemelos...&#34;)
    widgets = [
            pb.Percentage(),
            &#34; (&#34;, pb.SimpleProgress(), &#34;) &#34;,
            pb.Bar(), &#34; &#34;,
            pb.FormatLabel(&#34;&#34;), &#34; &#34;,
            pb.Timer(), &#34; &#34;,
            pb.ETA(), &#34; &#34;
        ]
    bar = pb.ProgressBar(max_value=len(users), widgets=widgets)
    i = 0
    for username in bar(users):
        if i &gt; 100:
            break
        widgets[6] = pb.FormatLabel(&#34;User: &#34; + username + &#34; &#34;)
        find_twins(users[username], args.user_index)
        i +=1
               
    with open(&#34;users_and_possible_twins.pickle&#34;, &#34;wb&#34;) as f:
        pickle.dump(users, f)

    set_users = set()
    for user in users:
        for u in users[user][&#34;possible_twins&#34;]:
            set_users.add(u[&#34;name&#34;])
    
    print(len(set_users))

    # Filtrar por número de posts

    # Escoger el mejor

    pass

def get_users(index):
    res = helpers.scan(es, index=index,
    query={
        &#34;query&#34;:{
            &#34;range&#34;:{
                &#34;created_utc&#34;:{
                    &#34;lt&#34;: 1539897781 # Fecha máxima en el índice de usuarios + 30 días
                }
            }
        }
    })
    
    users = {}
    bar = pb.ProgressBar()
    for user in bar(res):
        data = user[&#34;_source&#34;]
        users[data[&#34;name&#34;]] = {
            &#34;created_utc&#34;: data[&#34;created_utc&#34;],
            &#34;comment_karma&#34;: data[&#34;comment_karma&#34;],
            &#34;link_karma&#34;: data[&#34;link_karma&#34;],
            &#34;posts&#34;: data[&#34;posts&#34;],
            &#34;possible_twins&#34;: []
        }
    return users

def find_twins(user, index):
    MONTH_IN_SECONDS = 30*24*3600 

    bounds = {
        &#34;intervals&#34;: get_time_intervals(user[&#34;created_utc&#34;]),
        &#34;comment_low&#34;: user[&#34;comment_karma&#34;] - user[&#34;comment_karma&#34;]*0.1,
        &#34;comment_high&#34;: user[&#34;comment_karma&#34;] + user[&#34;comment_karma&#34;]*0.1,
        &#34;link_low&#34;: user[&#34;link_karma&#34;] - user[&#34;link_karma&#34;]*0.1,
        &#34;link_high&#34;: user[&#34;link_karma&#34;] + user[&#34;link_karma&#34;]*0.1
    }

    num_hits = 0
    i = 0
    while num_hits &lt; MAX_USERS and i &lt; len(bounds[&#34;intervals&#34;]):
        res = es.search(index = index,
            body = {
                &#34;size&#34;: MAX_USERS,
                &#34;query&#34;:{
                    &#34;bool&#34;:{
                        &#34;must&#34;:[
                            {
                                &#34;range&#34;:{
                                    &#34;created_utc&#34;:{
                                        &#34;gte&#34;: bounds[&#34;intervals&#34;][i][&#34;date_old&#34;],
                                        &#34;lte&#34;: bounds[&#34;intervals&#34;][i][&#34;date_new&#34;]
                                    }
                                }
                            },
                            {
                                &#34;range&#34;:{
                                    &#34;comment_karma&#34;:{
                                        &#34;gte&#34;: bounds[&#34;comment_low&#34;],
                                        &#34;lte&#34;: bounds[&#34;comment_high&#34;]
                                    }
                                }
                            },
                            {
                                &#34;range&#34;:{
                                    &#34;link_karma&#34;:{
                                        &#34;gte&#34;: bounds[&#34;link_low&#34;],
                                        &#34;lte&#34;: bounds[&#34;link_high&#34;]
                                    }
                                }
                            }
                        ]
                    }

                }
            }
        )
        num_hits = res[&#34;hits&#34;][&#34;total&#34;][&#34;value&#34;]
        hits = res[&#34;hits&#34;][&#34;hits&#34;]
        i+=1

    user[&#34;possible_twins&#34;] = [hit[&#34;_source&#34;] for hit in hits]
            
def get_time_intervals(timestamp):
    &#34;&#34;&#34;
        Devuelve una lista de fechas en timestamp con los límites de los siguientes intervalos:
            * +/- 12 horas en el mismo día
            * +/- 24 horas
            * +/- 3.5 días en la misma semana
            * +/- 3 días
            * +/- 15 días en el mismo mes
            * +/- 30 días

        Parámetros
        ----------
        timestamp: int
            \t Timestamp de la fecha entorno a la cuál se calculan los intervalos

        Salida
        ------
        list
            \tLista con los timestamps correspondientes a los límites de los rangos
    &#34;&#34;&#34;
    bounds = []
    
    date = dt.fromtimestamp(timestamp)

    # Intervalo 12 horas pero dentro del mismo día
    beginning_day = date.replace(hour=00, minute=00, second=00)
    end_day = date.replace(hour=23, minute=59, second=59)

    half_day_beginning = max(beginning_day, date - timedelta(hours=12)).timestamp()
    half_day_end = min(end_day, date + timedelta(hours=12)).timestamp()
    bounds.append({&#34;date_old&#34;: half_day_beginning, &#34;date_new&#34;: half_day_end })

    # Intervalo 24 horas
    bounds.append({&#34;date_old&#34;: (date - timedelta(hours=24)).timestamp(),
        &#34;date_new&#34;: (date + timedelta(hours=24)).timestamp()})

    # Intervalo 3.5 días pero en la misma semana
    ## Se calcula el primer día de la semana
    beginning_week = date - timedelta(days=date.weekday())
    beginning_week = beginning_week.replace(hour=00, minute=00, second=00)
    ## Se calcula el último
    end_week = beginning_week + timedelta(days=6)
    end_week = end_week.replace(hour=23, minute=59, second=59)
    ## Se calculan el rango de 3.5 días asegurándose de no salir de la semana
    half_week_beginning = max(beginning_week, date - timedelta(days=3.5)).timestamp()
    half_week_end = min(end_week, date + timedelta(days=3.5)).timestamp()
    bounds.append({&#34;date_old&#34;: half_week_beginning, &#34;date_new&#34;: half_week_end})

    # Intervalo 3 días
    bounds.append({&#34;date_old&#34;: (date - timedelta(days=3)).timestamp(),
        &#34;date_new&#34;: (date + timedelta(days=3)).timestamp()})

    # Intervalo 15 días pero dentro del mismo mes
    beginning_month = date.replace(day=1, hour=00, minute=00, second=00)
    ## Se saca el último día del mes
    next_month = date.replace(day=28) + timedelta(days=4)
    end_month = next_month - timedelta(days=next_month.day)
    end_month = end_month.replace(hour=23, minute=59, second=59)
    ## Se calcula el rango de 15 días sin salirse del mes
    half_month_beginning = max(beginning_month, date - timedelta(days=15)).timestamp()
    half_month_end = min(end_month, date + timedelta(days=15)).timestamp()
    bounds.append({&#34;date_old&#34;: half_month_beginning, &#34;date_new&#34;: half_month_end})

    # Intervalo 30 días
    bounds.append({&#34;date_old&#34;: (date - timedelta(days=30)).timestamp(),
        &#34;date_new&#34;: (date + timedelta(days=30)).timestamp()})
    

    return bounds

def parse_args():
    &#34;&#34;&#34;
        Procesamiento de los argumentos con los que se ejecutó el script
    &#34;&#34;&#34;
    parser = argparse.ArgumentParser(description=&#34;Script para obtener usuarios &#39;gemelos&#39;&#34;)
    parser.add_argument(&#34;-s&#34;, &#34;--source-users&#34;, default=&#34;users-r-lonely&#34;, help=&#34;Nombre del índice de Elasticsearch del que se recuperaran los usuarios de los que se quieren encontrar gemelos&#34;)
    parser.add_argument(&#34;-u&#34;, &#34;--user-index&#34;, default=&#34;users-reddit&#34;, help=&#34;Nombre del índice de Elasticsearch con los usuarios candidatos a ser gemelos&#34;)
    parser.add_argument(&#34;-e&#34;, &#34;--elasticsearch&#34;, default=&#34;http://localhost:9200&#34;, help=&#34;dirección del servidor Elasticsearch&#34;)
    parser.add_argument(&#34;-b&#34;, &#34;--before&#34;, default=date.today(), 
        type= lambda d: dt.strptime(d, &#39;%Y-%m-%d&#39;).date(), 
        help=&#34;Fecha límite para obtener el número de posts de los usuarios&#34;)
    return parser.parse_args()

if __name__==&#34;__main__&#34;:
    main(parse_args())</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="src.users.find_twins.find_twins"><code class="name flex">
<span>def <span class="ident">find_twins</span></span>(<span>user, index)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_twins(user, index):
    MONTH_IN_SECONDS = 30*24*3600 

    bounds = {
        &#34;intervals&#34;: get_time_intervals(user[&#34;created_utc&#34;]),
        &#34;comment_low&#34;: user[&#34;comment_karma&#34;] - user[&#34;comment_karma&#34;]*0.1,
        &#34;comment_high&#34;: user[&#34;comment_karma&#34;] + user[&#34;comment_karma&#34;]*0.1,
        &#34;link_low&#34;: user[&#34;link_karma&#34;] - user[&#34;link_karma&#34;]*0.1,
        &#34;link_high&#34;: user[&#34;link_karma&#34;] + user[&#34;link_karma&#34;]*0.1
    }

    num_hits = 0
    i = 0
    while num_hits &lt; MAX_USERS and i &lt; len(bounds[&#34;intervals&#34;]):
        res = es.search(index = index,
            body = {
                &#34;size&#34;: MAX_USERS,
                &#34;query&#34;:{
                    &#34;bool&#34;:{
                        &#34;must&#34;:[
                            {
                                &#34;range&#34;:{
                                    &#34;created_utc&#34;:{
                                        &#34;gte&#34;: bounds[&#34;intervals&#34;][i][&#34;date_old&#34;],
                                        &#34;lte&#34;: bounds[&#34;intervals&#34;][i][&#34;date_new&#34;]
                                    }
                                }
                            },
                            {
                                &#34;range&#34;:{
                                    &#34;comment_karma&#34;:{
                                        &#34;gte&#34;: bounds[&#34;comment_low&#34;],
                                        &#34;lte&#34;: bounds[&#34;comment_high&#34;]
                                    }
                                }
                            },
                            {
                                &#34;range&#34;:{
                                    &#34;link_karma&#34;:{
                                        &#34;gte&#34;: bounds[&#34;link_low&#34;],
                                        &#34;lte&#34;: bounds[&#34;link_high&#34;]
                                    }
                                }
                            }
                        ]
                    }

                }
            }
        )
        num_hits = res[&#34;hits&#34;][&#34;total&#34;][&#34;value&#34;]
        hits = res[&#34;hits&#34;][&#34;hits&#34;]
        i+=1

    user[&#34;possible_twins&#34;] = [hit[&#34;_source&#34;] for hit in hits]</code></pre>
</details>
</dd>
<dt id="src.users.find_twins.get_time_intervals"><code class="name flex">
<span>def <span class="ident">get_time_intervals</span></span>(<span>timestamp)</span>
</code></dt>
<dd>
<div class="desc"><p>Devuelve una lista de fechas en timestamp con los límites de los siguientes intervalos:
* +/- 12 horas en el mismo día
* +/- 24 horas
* +/- 3.5 días en la misma semana
* +/- 3 días
* +/- 15 días en el mismo mes
* +/- 30 días</p>
<h2 id="parametros">Parámetros</h2>
<p>timestamp: int
Timestamp de la fecha entorno a la cuál se calculan los intervalos</p>
<h2 id="salida">Salida</h2>
<p>list
Lista con los timestamps correspondientes a los límites de los rangos</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_time_intervals(timestamp):
    &#34;&#34;&#34;
        Devuelve una lista de fechas en timestamp con los límites de los siguientes intervalos:
            * +/- 12 horas en el mismo día
            * +/- 24 horas
            * +/- 3.5 días en la misma semana
            * +/- 3 días
            * +/- 15 días en el mismo mes
            * +/- 30 días

        Parámetros
        ----------
        timestamp: int
            \t Timestamp de la fecha entorno a la cuál se calculan los intervalos

        Salida
        ------
        list
            \tLista con los timestamps correspondientes a los límites de los rangos
    &#34;&#34;&#34;
    bounds = []
    
    date = dt.fromtimestamp(timestamp)

    # Intervalo 12 horas pero dentro del mismo día
    beginning_day = date.replace(hour=00, minute=00, second=00)
    end_day = date.replace(hour=23, minute=59, second=59)

    half_day_beginning = max(beginning_day, date - timedelta(hours=12)).timestamp()
    half_day_end = min(end_day, date + timedelta(hours=12)).timestamp()
    bounds.append({&#34;date_old&#34;: half_day_beginning, &#34;date_new&#34;: half_day_end })

    # Intervalo 24 horas
    bounds.append({&#34;date_old&#34;: (date - timedelta(hours=24)).timestamp(),
        &#34;date_new&#34;: (date + timedelta(hours=24)).timestamp()})

    # Intervalo 3.5 días pero en la misma semana
    ## Se calcula el primer día de la semana
    beginning_week = date - timedelta(days=date.weekday())
    beginning_week = beginning_week.replace(hour=00, minute=00, second=00)
    ## Se calcula el último
    end_week = beginning_week + timedelta(days=6)
    end_week = end_week.replace(hour=23, minute=59, second=59)
    ## Se calculan el rango de 3.5 días asegurándose de no salir de la semana
    half_week_beginning = max(beginning_week, date - timedelta(days=3.5)).timestamp()
    half_week_end = min(end_week, date + timedelta(days=3.5)).timestamp()
    bounds.append({&#34;date_old&#34;: half_week_beginning, &#34;date_new&#34;: half_week_end})

    # Intervalo 3 días
    bounds.append({&#34;date_old&#34;: (date - timedelta(days=3)).timestamp(),
        &#34;date_new&#34;: (date + timedelta(days=3)).timestamp()})

    # Intervalo 15 días pero dentro del mismo mes
    beginning_month = date.replace(day=1, hour=00, minute=00, second=00)
    ## Se saca el último día del mes
    next_month = date.replace(day=28) + timedelta(days=4)
    end_month = next_month - timedelta(days=next_month.day)
    end_month = end_month.replace(hour=23, minute=59, second=59)
    ## Se calcula el rango de 15 días sin salirse del mes
    half_month_beginning = max(beginning_month, date - timedelta(days=15)).timestamp()
    half_month_end = min(end_month, date + timedelta(days=15)).timestamp()
    bounds.append({&#34;date_old&#34;: half_month_beginning, &#34;date_new&#34;: half_month_end})

    # Intervalo 30 días
    bounds.append({&#34;date_old&#34;: (date - timedelta(days=30)).timestamp(),
        &#34;date_new&#34;: (date + timedelta(days=30)).timestamp()})
    

    return bounds</code></pre>
</details>
</dd>
<dt id="src.users.find_twins.get_users"><code class="name flex">
<span>def <span class="ident">get_users</span></span>(<span>index)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_users(index):
    res = helpers.scan(es, index=index,
    query={
        &#34;query&#34;:{
            &#34;range&#34;:{
                &#34;created_utc&#34;:{
                    &#34;lt&#34;: 1539897781 # Fecha máxima en el índice de usuarios + 30 días
                }
            }
        }
    })
    
    users = {}
    bar = pb.ProgressBar()
    for user in bar(res):
        data = user[&#34;_source&#34;]
        users[data[&#34;name&#34;]] = {
            &#34;created_utc&#34;: data[&#34;created_utc&#34;],
            &#34;comment_karma&#34;: data[&#34;comment_karma&#34;],
            &#34;link_karma&#34;: data[&#34;link_karma&#34;],
            &#34;posts&#34;: data[&#34;posts&#34;],
            &#34;possible_twins&#34;: []
        }
    return users</code></pre>
</details>
</dd>
<dt id="src.users.find_twins.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>args)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main(args):
    global es, api
    es = Elasticsearch(args.elasticsearch)
    
    # Extraer usuarios del primer índice
    print(&#34;Recuperando usuarios de /r/lonely...&#34;)
    users = get_users(args.source_users)

    # Buscar usuarios &#34;gemelos&#34;
    print(&#34;Obteniendo posibles gemelos...&#34;)
    widgets = [
            pb.Percentage(),
            &#34; (&#34;, pb.SimpleProgress(), &#34;) &#34;,
            pb.Bar(), &#34; &#34;,
            pb.FormatLabel(&#34;&#34;), &#34; &#34;,
            pb.Timer(), &#34; &#34;,
            pb.ETA(), &#34; &#34;
        ]
    bar = pb.ProgressBar(max_value=len(users), widgets=widgets)
    i = 0
    for username in bar(users):
        if i &gt; 100:
            break
        widgets[6] = pb.FormatLabel(&#34;User: &#34; + username + &#34; &#34;)
        find_twins(users[username], args.user_index)
        i +=1
               
    with open(&#34;users_and_possible_twins.pickle&#34;, &#34;wb&#34;) as f:
        pickle.dump(users, f)

    set_users = set()
    for user in users:
        for u in users[user][&#34;possible_twins&#34;]:
            set_users.add(u[&#34;name&#34;])
    
    print(len(set_users))

    # Filtrar por número de posts

    # Escoger el mejor

    pass</code></pre>
</details>
</dd>
<dt id="src.users.find_twins.parse_args"><code class="name flex">
<span>def <span class="ident">parse_args</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Procesamiento de los argumentos con los que se ejecutó el script</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_args():
    &#34;&#34;&#34;
        Procesamiento de los argumentos con los que se ejecutó el script
    &#34;&#34;&#34;
    parser = argparse.ArgumentParser(description=&#34;Script para obtener usuarios &#39;gemelos&#39;&#34;)
    parser.add_argument(&#34;-s&#34;, &#34;--source-users&#34;, default=&#34;users-r-lonely&#34;, help=&#34;Nombre del índice de Elasticsearch del que se recuperaran los usuarios de los que se quieren encontrar gemelos&#34;)
    parser.add_argument(&#34;-u&#34;, &#34;--user-index&#34;, default=&#34;users-reddit&#34;, help=&#34;Nombre del índice de Elasticsearch con los usuarios candidatos a ser gemelos&#34;)
    parser.add_argument(&#34;-e&#34;, &#34;--elasticsearch&#34;, default=&#34;http://localhost:9200&#34;, help=&#34;dirección del servidor Elasticsearch&#34;)
    parser.add_argument(&#34;-b&#34;, &#34;--before&#34;, default=date.today(), 
        type= lambda d: dt.strptime(d, &#39;%Y-%m-%d&#39;).date(), 
        help=&#34;Fecha límite para obtener el número de posts de los usuarios&#34;)
    return parser.parse_args()</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="src.users" href="index.html">src.users</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="src.users.find_twins.find_twins" href="#src.users.find_twins.find_twins">find_twins</a></code></li>
<li><code><a title="src.users.find_twins.get_time_intervals" href="#src.users.find_twins.get_time_intervals">get_time_intervals</a></code></li>
<li><code><a title="src.users.find_twins.get_users" href="#src.users.find_twins.get_users">get_users</a></code></li>
<li><code><a title="src.users.find_twins.main" href="#src.users.find_twins.main">main</a></code></li>
<li><code><a title="src.users.find_twins.parse_args" href="#src.users.find_twins.parse_args">parse_args</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>